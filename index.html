<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#000000" />
  <title>Naclara & Gabies</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    html,body{overflow:hidden;position:fixed;width:100%;height:100%;height:100dvh;background:#000;touch-action:none;-webkit-user-select:none;user-select:none}
    canvas{position:fixed;top:0;left:0;width:100vw;height:100vh;height:100dvh;z-index:1;touch-action:none}
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// =============================================
// FOGOS DE ARTIFÍCIO - INTERATIVO MOBILE
// Explosões INSTANTÂNEAS no dedo, sem delay
// Otimizado para iPhone 11
// =============================================

const C = document.getElementById('c');
const ctx = C.getContext('2d', { alpha: false });
const dpr = Math.min(window.devicePixelRatio || 2, 2);
let W, H;

function resize() {
  W = window.innerWidth * dpr;
  H = window.innerHeight * dpr;
  C.width = W; C.height = H;
  C.style.width = '100%'; C.style.height = '100%';
}
resize();
window.addEventListener('resize', resize);

// --- Pool de partículas para evitar GC ---
const MAX_P = 3000;
const px = new Float32Array(MAX_P);
const py = new Float32Array(MAX_P);
const pvx = new Float32Array(MAX_P);
const pvy = new Float32Array(MAX_P);
const pa = new Float32Array(MAX_P);  // alpha
const pr = new Float32Array(MAX_P);  // red
const pg = new Float32Array(MAX_P);  // green
const pb = new Float32Array(MAX_P);  // blue
const pdc = new Float32Array(MAX_P); // decay
const psz = new Float32Array(MAX_P); // size
const pfr = new Float32Array(MAX_P); // friction
const pgr = new Float32Array(MAX_P); // gravity
const pfl = new Float32Array(MAX_P); // flicker phase
const pfs = new Float32Array(MAX_P); // flicker speed
let pCount = 0;

function addParticle(x, y, vx, vy, r, g, b, alpha, decay, size, friction, gravity, flPhase, flSpeed) {
  if (pCount >= MAX_P) return;
  const i = pCount++;
  px[i]=x; py[i]=y; pvx[i]=vx; pvy[i]=vy;
  pr[i]=r; pg[i]=g; pb[i]=b; pa[i]=alpha;
  pdc[i]=decay; psz[i]=size; pfr[i]=friction; pgr[i]=gravity;
  pfl[i]=flPhase; pfs[i]=flSpeed;
}

function removeParticle(i) {
  pCount--;
  if (i < pCount) {
    px[i]=px[pCount]; py[i]=py[pCount]; pvx[i]=pvx[pCount]; pvy[i]=pvy[pCount];
    pr[i]=pr[pCount]; pg[i]=pg[pCount]; pb[i]=pb[pCount]; pa[i]=pa[pCount];
    pdc[i]=pdc[pCount]; psz[i]=psz[pCount]; pfr[i]=pfr[pCount]; pgr[i]=pgr[pCount];
    pfl[i]=pfl[pCount]; pfs[i]=pfs[pCount];
  }
}

// --- Cores ---
function white() {
  const v = 210 + Math.random()*45;
  const t = Math.random();
  if (t < 0.5) return [v, v, v];
  if (t < 0.75) return [v, v*0.95, v*0.88];
  return [v*0.9, v*0.95, v];
}

function gold() { return [255, 200+Math.random()*40, 80+Math.random()*50]; }

function randColor() {
  const r = Math.random();
  if (r < 0.55) return white();
  if (r < 0.8) return gold();
  return [210+Math.random()*45, 210+Math.random()*45, 255];
}

// --- Tipos de explosão (INSTANTÂNEA no ponto) ---

// Chrysanthemum - esfera densa
function chrysanthemum(x, y) {
  const n = 60 + Math.floor(Math.random()*30);
  const c = randColor();
  for (let i = 0; i < n; i++) {
    const a = Math.random()*6.2832;
    const phi = Math.acos(2*Math.random()-1);
    const sp = 1.5 + Math.random()*3.5;
    const br = 0.7+Math.random()*0.3;
    addParticle(x, y,
      Math.cos(a)*Math.sin(phi)*sp, Math.sin(a)*Math.sin(phi)*sp*0.8,
      c[0]*br, c[1]*br, c[2]*br, 1,
      0.006+Math.random()*0.006, 1+Math.random()*1.5,
      0.978, 0.022+Math.random()*0.008,
      Math.random()*6.28, 4+Math.random()*8
    );
  }
}

// Star - formato estrela
function star(x, y) {
  const pts = Math.random()>0.5 ? 5 : 6;
  const n = 50 + Math.floor(Math.random()*25);
  const c = randColor();
  for (let i = 0; i < n; i++) {
    const arm = Math.floor(Math.random()*pts);
    const ba = (arm/pts)*6.2832 - 1.5708;
    const a = ba + (Math.random()-0.5)*0.35;
    const sp = 1.2+Math.random()*3.5;
    addParticle(x, y,
      Math.cos(a)*sp, Math.sin(a)*sp,
      c[0], c[1], c[2], 1,
      0.007+Math.random()*0.006, 1.2+Math.random()*1.2,
      0.977, 0.02+Math.random()*0.008,
      Math.random()*6.28, 6+Math.random()*8
    );
  }
  // Centro
  for (let i = 0; i < 8; i++) {
    const a = Math.random()*6.28;
    addParticle(x, y,
      Math.cos(a)*0.5, Math.sin(a)*0.5,
      255, 255, 255, 1,
      0.025, 1.8+Math.random(), 0.96, 0.015, 0, 10
    );
  }
}

// Peony - esférica grande
function peony(x, y) {
  const n = 45+Math.floor(Math.random()*20);
  const c = randColor();
  for (let i = 0; i < n; i++) {
    const a = Math.random()*6.2832;
    const sp = 1+Math.random()*3.5;
    const br = 0.7+Math.random()*0.3;
    addParticle(x, y,
      Math.cos(a)*sp, Math.sin(a)*sp*0.85,
      c[0]*br, c[1]*br, c[2]*br, 1,
      0.007+Math.random()*0.007, 1.5+Math.random()*2,
      0.975, 0.025+Math.random()*0.01,
      Math.random()*6.28, 5+Math.random()*8
    );
  }
}

// Willow - cai como salgueiro
function willow(x, y) {
  const n = 50+Math.floor(Math.random()*25);
  const c = gold();
  for (let i = 0; i < n; i++) {
    const a = Math.random()*6.2832;
    const sp = 0.8+Math.random()*2.8;
    addParticle(x, y,
      Math.cos(a)*sp, Math.sin(a)*sp*0.6 - 0.8,
      c[0], c[1], c[2], 1,
      0.003+Math.random()*0.003, 0.8+Math.random()*1,
      0.988, 0.04+Math.random()*0.015,
      Math.random()*6.28, 3+Math.random()*4
    );
  }
}

// Sparkle burst - mini explosão de faíscas
function sparkle(x, y) {
  const n = 25+Math.floor(Math.random()*15);
  for (let i = 0; i < n; i++) {
    const a = Math.random()*6.2832;
    const sp = 0.5+Math.random()*2;
    addParticle(x, y,
      Math.cos(a)*sp, Math.sin(a)*sp,
      255, 255, 255, 1,
      0.015+Math.random()*0.015, 0.5+Math.random()*0.8,
      0.97, 0.018,
      Math.random()*6.28, 10+Math.random()*10
    );
  }
}

// Crackle - mini estouros
function crackle(x, y) {
  const n = 35+Math.floor(Math.random()*15);
  const c = randColor();
  for (let i = 0; i < n; i++) {
    const a = Math.random()*6.2832;
    const sp = 2+Math.random()*3;
    addParticle(x, y,
      Math.cos(a)*sp, Math.sin(a)*sp,
      c[0], c[1], c[2], 1,
      0.012+Math.random()*0.01, 0.8+Math.random()*1,
      0.965, 0.03+Math.random()*0.01,
      Math.random()*6.28, 8+Math.random()*8
    );
  }
}

// Array de tipos
const TYPES = [chrysanthemum, star, peony, willow, sparkle, crackle];

function randomExplosion(x, y) {
  TYPES[Math.floor(Math.random()*TYPES.length)](x, y);
}

// Flash no ponto da explosão
function flash(x, y) {
  ctx.globalCompositeOperation = 'lighter';
  const g = ctx.createRadialGradient(x, y, 0, x, y, 40*dpr);
  g.addColorStop(0, 'rgba(255,255,255,0.5)');
  g.addColorStop(0.3, 'rgba(255,255,255,0.15)');
  g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.beginPath();
  ctx.arc(x, y, 40*dpr, 0, 6.2832);
  ctx.fillStyle = g;
  ctx.fill();
}

// === INTERAÇÃO - TOQUE E ARRASTAR ===
let lastTouchX = 0, lastTouchY = 0;
let lastExplodeTime = 0;
const EXPLODE_INTERVAL = 60; // Explodir a cada 60ms ao arrastar (muito responsivo)

function getCanvasPos(e) {
  let cx, cy;
  if (e.touches && e.touches.length > 0) {
    cx = e.touches[0].clientX;
    cy = e.touches[0].clientY;
  } else {
    cx = e.clientX;
    cy = e.clientY;
  }
  const rect = C.getBoundingClientRect();
  return {
    x: (cx - rect.left) * (W / rect.width),
    y: (cy - rect.top) * (H / rect.height)
  };
}

function explodeAt(x, y) {
  flash(x, y);
  randomExplosion(x, y);
  // Chance de dupla explosão
  if (Math.random() > 0.6) {
    setTimeout(() => randomExplosion(x + (Math.random()-0.5)*40, y + (Math.random()-0.5)*40), 50);
  }
}

function onTouchStart(e) {
  e.preventDefault();
  const p = getCanvasPos(e);
  lastTouchX = p.x; lastTouchY = p.y;
  explodeAt(p.x, p.y);
  lastExplodeTime = performance.now();
}

function onTouchMove(e) {
  e.preventDefault();
  const now = performance.now();
  const p = getCanvasPos(e);
  lastTouchX = p.x; lastTouchY = p.y;

  if (now - lastExplodeTime >= EXPLODE_INTERVAL) {
    explodeAt(p.x, p.y);
    lastExplodeTime = now;
  }
}

// Touch
C.addEventListener('touchstart', onTouchStart, { passive: false });
C.addEventListener('touchmove', onTouchMove, { passive: false });

// Mouse
let mouseDown = false;
C.addEventListener('mousedown', function(e) {
  mouseDown = true;
  const p = getCanvasPos(e);
  explodeAt(p.x, p.y);
  lastExplodeTime = performance.now();
});
C.addEventListener('mousemove', function(e) {
  if (!mouseDown) return;
  const now = performance.now();
  if (now - lastExplodeTime >= EXPLODE_INTERVAL) {
    const p = getCanvasPos(e);
    explodeAt(p.x, p.y);
    lastExplodeTime = now;
  }
});
C.addEventListener('mouseup', function() { mouseDown = false; });
C.addEventListener('mouseleave', function() { mouseDown = false; });

// === AUTO-LAUNCH (fogos automáticos de fundo) ===
let lastAuto = 0;

function autoLaunch(time) {
  if (time - lastAuto > 1200 + Math.random()*1000) {
    const x = Math.random()*W*0.8 + W*0.1;
    const y = Math.random()*H*0.4 + H*0.05;
    explodeAt(x, y);
    lastAuto = time;
  }
}

// Fogos iniciais
setTimeout(() => explodeAt(W*0.3, H*0.25), 200);
setTimeout(() => explodeAt(W*0.7, H*0.2), 500);
setTimeout(() => explodeAt(W*0.5, H*0.35), 800);

// === LOOP DE ANIMAÇÃO ===
function animate(time) {
  // Fade - fundo preto com transparência para criar trails
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.fillRect(0, 0, W, H);

  ctx.globalCompositeOperation = 'lighter';

  // Auto fogos
  autoLaunch(time);

  // Atualizar e desenhar partículas
  for (let i = pCount - 1; i >= 0; i--) {
    // Física
    pvx[i] *= pfr[i];
    pvy[i] *= pfr[i];
    pvy[i] += pgr[i];
    px[i] += pvx[i];
    py[i] += pvy[i];
    pa[i] -= pdc[i];

    if (pa[i] <= 0) { removeParticle(i); continue; }

    // Cintilação
    let fl = 1;
    if (pfs[i] > 0) {
      fl = 0.55 + 0.45 * Math.sin(time * 0.001 * pfs[i] + pfl[i]);
      if (Math.random() < 0.02) fl *= 0.15; // Piscar estrela
    }

    const alpha = pa[i] * fl;
    if (alpha < 0.01) continue;

    const sz = psz[i] * dpr;
    const ri = pr[i]|0;
    const gi = pg[i]|0;
    const bi = pb[i]|0;

    // Desenhar partícula
    ctx.beginPath();
    ctx.arc(px[i], py[i], sz, 0, 6.2832);
    ctx.fillStyle = `rgba(${ri},${gi},${bi},${alpha})`;
    ctx.fill();

    // Glow suave
    if (sz > 1 && alpha > 0.15) {
      const gg = ctx.createRadialGradient(px[i],py[i],0, px[i],py[i], sz*2.5);
      gg.addColorStop(0, `rgba(${ri},${gi},${bi},${alpha*0.12})`);
      gg.addColorStop(1, `rgba(${ri},${gi},${bi},0)`);
      ctx.beginPath();
      ctx.arc(px[i], py[i], sz*2.5, 0, 6.2832);
      ctx.fillStyle = gg;
      ctx.fill();
    }
  }

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>
</body>
</html>
